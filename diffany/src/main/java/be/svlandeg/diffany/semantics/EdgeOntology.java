package be.svlandeg.diffany.semantics;

import java.util.*;

import be.svlandeg.diffany.concepts.EdgeDefinition;

/**
 * This class takes care of the semantic interpretation of different edge types and their corresponding categories
 * in the 'source' networks, i.e. the reference and condition-specific networks used as input. 
 * It can define a differential edge by inspecting the two original edges (implemented by overriding classes).
 * Additionally, a shared edge can be generated by taking into account the edge type-to-category mapping 
 * and the direct super classes of categories.
 * 
 * (TODO: implement a more extensive ontology tree rather than only 1-level parent-child mappings)
 * 
 * @author Sofie Van Landeghem
 */
public abstract class EdgeOntology
{

	public static final String VOID_TYPE = EdgeDefinition.getVoidEdge().getType().toLowerCase();
	
	private Map<String, String> sourceCatHierarchy;

	private Map<String, String> mapSourceEdgeToCategory;
	private Set<String> allSourceCategories;
	
	private Set<String> allDiffCategories;

	/**
	 * Create an empty ontology, with no edge categories or any mapping defined
	 */
	public EdgeOntology()
	{
		removeAllCategoriesAndMappings();
		sourceCatHierarchy = new HashMap<String, String>();
	}

	/**
	 * Method that defines the differential edge from the corresponding edge categories in the reference and condition-specific networks.
	 * Returns EdgeDefinition.getVoidEdge() when the edge should be deleted (i.e. not present in differential network).
	 * 
	 * @param refEdge the edge definition in the reference network (can be a EdgeDefinition.getVoidEdge() when non-existing)
	 * @param conEdge the edge definition in the condition-specific network (can be a EdgeDefinition.getVoidEdge() when non-existing)
	 * @param cutoff the minimal value of a resulting edge for it to be included in the differential network
	 * 
	 * @return the edge definition in the differential network, or EdgeDefinition.getVoidEdge() when there should be no such edge (never null).
	 * @throws IllegalArgumentException when the type of the reference or condition-specific edge does not exist in this ontology
	 */
	public abstract EdgeDefinition getDifferentialEdge(EdgeDefinition refEdge, EdgeDefinition conEdge, double cutoff) throws IllegalArgumentException;

	/**
	 * Method that defines the overlapping edge from the corresponding edge categories in the reference and condition-specific networks.
	 * Returns EdgeDefinition.getVoidEdge() when the edge should be deleted (i.e. not present in the shared network).
	 * 
	 * @param refEdge the edge definition in the reference network (can be a EdgeDefinition.getVoidEdge() when non-existing)
	 * @param conEdge the edge definition in the condition-specific network (can be a EdgeDefinition.getVoidEdge() when non-existing)
	 * @param cutoff the minimal value of a resulting edge for it to be included in the shared network
	 * 
	 * @return the edge definition in the shared network, or EdgeDefinition.getVoidEdge() when there should be no such edge (never null).
	 * @throws IllegalArgumentException when the type of the reference or condition-specific edge does not exist in this ontology
	 */
	public EdgeDefinition getSharedEdge(EdgeDefinition refEdge, EdgeDefinition conEdge, double cutoff) throws IllegalArgumentException
	{
		EdgeDefinition shared_edge = new EdgeDefinition();

		String refCat = getSourceCategory(refEdge.getType());
		String conCat = getSourceCategory(conEdge.getType());
		
		boolean refNeg = refEdge.isNegated();
		boolean conNeg = conEdge.isNegated();

		if (refNeg != conNeg)
		{
			return EdgeDefinition.getVoidEdge();
		}
		
		shared_edge.makeNegated(refNeg);
			
		// the shared weight is the minimum between the two
		double sharedWeight = Math.min(refEdge.getWeight(), conEdge.getWeight());
		if (sharedWeight <= cutoff)
		{
			return EdgeDefinition.getVoidEdge();
		}
		shared_edge.setWeight(sharedWeight);

		// the shared edge is only symmetrical if both original edges are
		boolean refSymm = refEdge.isSymmetrical();
		boolean conSymm = conEdge.isSymmetrical();
		boolean sharedSymm = refSymm && conSymm;
		shared_edge.makeSymmetrical(sharedSymm);

		if (refCat.equals(conCat))
		{
			shared_edge.setType(refCat);
			return shared_edge;
		}
		if (isSourceChildOf(refCat,conCat))	// conCat is superclass
		{
			if (conNeg)	// there is negation -> shared edge is negated of type subclass
			{
				shared_edge.setType(refCat);
				return shared_edge;
			}
			else	// there is no negation -> shared edge is of type superclass
			{
				shared_edge.setType(conCat);
				return shared_edge;
			}
		}
		if (isSourceChildOf(conCat,refCat))	// refCat is superclass
		{
			if (refNeg)	// there is negation -> shared edge is negated of type subclass
			{
				shared_edge.setType(conCat);
				return shared_edge;
			}
			else	// there is no negation -> shared edge is of type superclass
			{
				shared_edge.setType(refCat);
				return shared_edge;
			}
		}
		String parent = commonSourceParent(conCat, refCat);
		if (parent != null)
		{
			shared_edge.setType(parent);
			return shared_edge;
		}
		
		return EdgeDefinition.getVoidEdge();
		
	}
	
	/**
	 * Get the semantic category of a certain edge type. Matching is done independent of upper/lower casing.
	 * 
	 * @param edgeType the original type of the edge in a network
	 * @return the semantic category of that edge or null if it is not mapped in this ontology
	 */
	public String getSourceCategory(String edgeType)
	{
		return mapSourceEdgeToCategory.get(edgeType.toLowerCase());
	}
	
	/**
	 * Check whether a certain edge type is present in this ontology. Matching is done independent of upper/lower casing.
	 * 
	 * @param edgeType the original type of the edge in a network
	 * @return whether or not this edge type is present in this ontology
	 */
	protected boolean isDefined(String edgeType)
	{
		if (edgeType == null)
		{
			return false;
		}
		return mapSourceEdgeToCategory.containsKey(edgeType.toLowerCase());
	}
	
	/**
	 * Return all source (input) categories present in this ontology.
	 * @return the set of categories mapped in this ontology.
	 */
	public Set<String> getAllSourceCategories()
	{
		return allSourceCategories;
	}
	
	/**
	 * Return all differential categories present in this ontology.
	 * @return the set of categories mapped in this ontology.
	 */
	public Set<String> getAllDiffCategories()
	{
		return allDiffCategories;
	}

	
	/**
	 * Add a differential category (casing independent)
	 * @param category the category that should be added to this ontology
	 * @throws IllegalArgumentException when the category is null
	 */
	protected void addDiffCategory(String category) throws IllegalArgumentException
	{
		if (category == null)
		{
			String errormsg = "The category should not be null!";
			throw new IllegalArgumentException(errormsg);
		}
		allDiffCategories.add(category.toLowerCase());
	}
	
	/**
	 * Add a number of differential categories (casing independent)
	 * @param categories the categories that should be added to this ontology
	 */
	protected void addDiffCategories(Set<String> categories)
	{
		for (String c : categories)
		{
			allDiffCategories.add(c.toLowerCase());
		}
	}

	/**
	 * Add a source category (casing independent)
	 * @param category the category that should be added to this ontology
	 * @throws IllegalArgumentException when the category is null
	 */
	protected void addSourceCategory(String category) throws IllegalArgumentException
	{
		if (category == null)
		{
			String errormsg = "The category should not be null!";
			throw new IllegalArgumentException(errormsg);
		}
		allSourceCategories.add(category.toLowerCase());
	}

	/**
	 * Add a number of source categories (casing independent)
	 * @param categories the categories that should be added to this ontology
	 */
	protected void addSourceCategories(Set<String> categories)
	{
		for (String c : categories)
		{
			allSourceCategories.add(c.toLowerCase());
		}
	}
	
	/**
	 * Define a child category and its parent category. The child should not have received a parent before.
	 * @param childCat the child category (subclass)
	 * @param parentCat the parent category (superclass)
	 * @throws IllegalArgumentException when the childCat was already previously attached to a parent or if either of the two categories are not defined in this ontology
	 */
	protected void putSourceParent(String childCat, String parentCat) throws IllegalArgumentException
	{
		if (sourceCatHierarchy.containsKey(childCat))
		{
			String errormsg = "The provided child category ('" + childCat + "') already has a parent category!";
			throw new IllegalArgumentException(errormsg);
		}
		if (!allSourceCategories.contains(childCat.toLowerCase()))
		{
			String errormsg = "The provided child category ('" + childCat + "') does not exist in this ontology!";
			throw new IllegalArgumentException(errormsg);
		}
		if (!allSourceCategories.contains(parentCat.toLowerCase()))
		{
			String errormsg = "The provided parent category ('" + parentCat + "') does not exist in this ontology!";
			throw new IllegalArgumentException(errormsg);
		}
		sourceCatHierarchy.put(childCat, parentCat);
	}
	
	/**
	 * Determine whether or not two categories are related to eachother as child (sub) - parent (super)
	 * @param childCat the subclass category
	 * @param parentCat the superclass category
	 * @return whether or not the parent relationship holds
	 */
	protected boolean isSourceChildOf(String childCat, String parentCat)
	{
		if (! sourceCatHierarchy.containsKey(childCat))
		{
			return false;
		}
		return sourceCatHierarchy.get(childCat).equals(parentCat);
	}
	
	/**
	 * Return the common parent of two categories, or null if there is none
	 * @param childCat1 the first child (sub) category
	 * @param childCat2 the second child (sub) category
	 * @return the common parent (super) category, or null if there is none such
	 */
	protected String commonSourceParent(String childCat1, String childCat2)
	{
		if (! sourceCatHierarchy.containsKey(childCat1))
		{
			return null;
		}
		if (! sourceCatHierarchy.containsKey(childCat2))
		{
			return null;
		}
		if (sourceCatHierarchy.get(childCat1).equals(sourceCatHierarchy.get(childCat2)))
		{
			return sourceCatHierarchy.get(childCat1);
		}
		return null;
	}

	/**
	 * Create a new mapping from edge type to category. Matching is done independent of upper/lower casing.
	 * 
	 * @param edgeType the original edge type - should not have been defined in this ontology before
	 * @param category the category to be assigned to this edge type
	 * @param overwrite determines whether or not this function may overwrite previous mappings of the same edge type
	 * @throws IllegalArgumentException when the edge type was already mapped in this ontology and overwrite is off,
	 * 	or when the specified category is not part of this ontology
	 */
	public void addSourceCategoryMapping(String edgeType, String category, boolean overwrite) throws IllegalArgumentException
	{
		if (!allSourceCategories.contains(category.toLowerCase()))
		{
			String errormsg = "The provided edge category ('" + category + "') does not exist in this ontology!";
			throw new IllegalArgumentException(errormsg);
		}
		if (!overwrite && mapSourceEdgeToCategory.containsKey(edgeType.toLowerCase()))
		{
			String errormsg = "The provided edge type is already mapped to a category!";
			throw new IllegalArgumentException(errormsg);
		}
		mapSourceEdgeToCategory.put(edgeType.toLowerCase(), category.toLowerCase());
	}

	/**
	 * Remove all categories and type-categoryMappings
	 */
	protected void removeAllCategoriesAndMappings()
	{
		allSourceCategories = new HashSet<String>();
		allSourceCategories.add(VOID_TYPE);
		
		allDiffCategories = new HashSet<String>();
		allDiffCategories.add(VOID_TYPE);

		mapSourceEdgeToCategory = new HashMap<String, String>();
		addSourceCategoryMapping(VOID_TYPE, VOID_TYPE, false);
	}

	/**
	 * Remove all type-category mappings (keeping all defined categories).
	 */
	protected void removeAllSourceCategoryMappings()
	{
		mapSourceEdgeToCategory = new HashMap<String, String>();
	}

}
